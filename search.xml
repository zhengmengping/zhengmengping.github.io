<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[this指向]]></title>
    <url>%2F2018%2F08%2F22%2Fthis%E6%8C%87%E5%90%91%2Fthis%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[关于this当一个函数被调用时，会创建一个活动记录（有时候也成为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this 就是这个记录的一个属性。 this全面解析调用位置首先清楚一个概念调用位置：调用位置就是函数在代码中被调用的位置（而不是声明位置）。例如： 1234function foo()&#123; // 声明位置 console.log(&quot;foo&quot;);&#125;foo(); // 调用位置 某些编程模式会隐藏真正的调用位置。最重要的是要分析调用栈（就是为了达到当前执行位置所调用的所有函数。也称为环境栈）。 123456789101112131415161718192021function baz()&#123; // 当前调用栈是：baz // 因此当前调用位置是全局作用域 console.log( &quot;baz&quot; ); bar(); // &lt;-- bar 的调用位置&#125;function bar()&#123; // 当前调用栈是：baz -&gt; bar // 因此当前调用位置在 baz 中 console.log( &quot;bar&quot; ); foo(); // &lt;-- foo 的调用位置&#125;function foo()&#123; // 当前调用栈是 baz -&gt; bar -&gt; foo // 因此当前调用位置在 bar 中 console.log( &quot;foo&quot; )&#125;baz(); // &lt;-- baz 的调用位置 首先，最后一句调用了 baz() ，所以那个位置就是baz() 的调用位置，将baz()添加到调用栈里。然后 baz()里面又调用了 bar()，所以 bar()的调用位置是在这，同样将bar()加入到调用栈里面。接着，bar()里面又调用了 foo()，所以 foo()的调用位置是在bar()里面，将 foo()加入到调用栈中。 明确调用位置对我们分析 this 的指向有很大的帮助。 绑定规则默认绑定默认绑定即独立的函数调用，当其他规则无法应用时的默认规则，如： 12345function foo()&#123; console.log(this.a);&#125;var a = 2 ;foo(); // 2 调用 foo()的时候其实相当于 window.foo()，所以 this.a 其实指向的是 window.a 隐式绑定12345678function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;obj.foo(); // 2 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文的对象。因为调用 foo()时 this 被绑定到obj，因此 this.a和obj.a是一样的 显示绑定即使用 apply()和 call()方法。它们的第一个参数是一个对象，在调用函数时将其绑定到 this。他们的主要区别就是第二个参数。看个例子 1234567891011121314function foo()&#123; console.log( this.a );&#125;var obj = &#123; a: 2,&#125;;var bar = function()&#123; foo.call( obj );&#125;;bar(); // 2setTimeout(bar,100) // 2// 显示绑定的 bar 不可能再修改它的 thisbar.call(window); // 2 我们创建了函数 bar()，并在内部调用了 foo.call(obj)，因此强制把 foo的 this 绑定到了 obj。之后无论如何调用 bar()，它总会手动在 obj 上调用 foo。这种绑定是一种强制绑定，也成为硬绑定。 由于硬绑定是一种非常常用的模式，所以 ES5 提供了 bind() 函数。用法如下 12345678910function foo(something)&#123; console.log( this.a, something ); return this.a + something;&#125;var obj = &#123; a:2&#125;var bar = foo.bind( obj );var b = bar(3); // 2 3;console.log(b); // 5 new绑定使用 new 调用函数只是对函数的 ” 构造调用 “，所有的函数都可以使用 new 来调用。使用 new 来调用函数时，会自动执行如下操作 创建（或者说构造）一个全新的对象 这个新对象会被执行 [[Prototype]] 连接 这个新对象会绑定到函数调用的 this 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象 用代码表示就是如下步骤 123456789101112function foo(a)&#123; this.a = a;&#125;var bar = new foo(2);console.log(bar.a); // 2// 其中 new foo(2) 进行的是类似如下的操作&#123; var obj = new Object(); obj.__proto__ = foo.prototype; var result = foo.call(obj,&quot;2&quot;); return result === &apos;object&apos; ? result : obj&#125; 使用 new 来调用 foo( … ) 时，我们会构造一个新对象并把它绑定到 foo( … ) 调用中的 this 优先级毫无疑问，默认绑定优先级最低接下来，我们看看其他绑定的优先级 12345678910111213141516function foo(a)&#123; console.log( this.a );&#125;var obj1 = &#123; a: 2, foo: foo&#125;;var obj2 = &#123; a: 3, foo: foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call(obj2); // 3obj2.foo.call(obj1); // 2// 显然，显式绑定优先级更高 123456789101112131415function foo(something)&#123; this.a = something;&#125;var obj1 = &#123; foo:foo&#125;;var obj2 = &#123;&#125;;obj1.foo( 2 );console.log( obj1.a ); // 2obj1.foo.call( obj2, 3 );console.log( obj2.a ); // 3var bar = new obj1.foo( 4 );console.log( obj1.a ); // 2console.log( bar.a ); // 4// 可以看到，new 绑定比隐式绑定优先级高 12345678910function foo(something)&#123; this.a = something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind( obj1 );bar( 2 );console.log( obj1.a ); // 2var baz = new bar(3); console.log( obj1.a ); // 2console.log( baz.a ); // 3 判断this 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象var bar = new foo() 函数是否通过 call、apply（显式绑定）或者硬绑定调用（bind）？如果是的话，this 绑定的是指定的对象 var bar = foo.call() 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。var bar = foo() 箭头函数箭头函数不适用 this 的四种标准规则，而是根据外层作用域来决定来看下面这个例子 123456789101112131415function foo()&#123; // 返回一个箭头函数 return (a)=&gt;&#123; // this 继承自 foo() console.log( this.a ); &#125;;&#125;var obj1 = &#123; a:2&#125;;var obj2 = &#123; a:3&#125;;var bar = foo.call( obj1 );// 调用位置bar.call( obj2 ); // 2,不是 3！ foo() 内部创建的箭头函数会捕获调用foo()时的this。由于 foo()的 this 绑定到 obj1，bar 的 this 也会绑定到 obj1，箭头函数的绑定无法修改。（new 绑定也不行！） ES6 标准入门里面对箭头函数 this 的指向有如下说法： 函数体内的 this 对象就是定义时所在的对象，而不是调用时所在的对象。 总结 箭头函数的 this 绑定看的是 this 所在的函数定义在哪个对象下，绑定到哪个对象则 this 就指向哪个对象 一般情况下是默认绑定，如果有 new 绑定则 new 绑定优先级最高，其次是显式绑定，然后再是隐式绑定。如果有对象嵌套的情况，则 this 绑定到最近的一层对象上]]></content>
      <categories>
        <category>this</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯css创建图形]]></title>
    <url>%2F2018%2F08%2F21%2F%E7%BA%AFcss%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%2F%E7%BA%AFcss%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[用css创建三角形 保证元素是块级元素 设置元素的边框 不需要显示的边框使用透明色 1234567div&#123; width:0; height:0; margin:0 auto; border:6px solid transparent; border-top: 6px solid red; &#125; 用css创建等腰梯形梯形的下底宽度为矩形“左右边框”的宽度加上矩形的宽度，上底的宽度等于矩形的宽度，梯形的高度为下边框的宽度。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;title&gt;测试&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;div &#123; width:120px;height:0;margin:100px auto; border-left:80px solid transparent; border-right:80px solid transparent; border-bottom:150px solid #8900CE;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 用css创建上底在下方的直角梯形123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;title&gt;测试&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;div &#123; width:120px;height:0;margin:100px auto; border-left:80px solid transparent; border-top:150px solid #00C1AE;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 用css创建六边形12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;title&gt;测试&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;.div1 &#123; width:160px;height:0;margin:100px auto 0 auto; border-left:75px solid transparent; border-right:75px solid transparent; border-bottom:135px solid #53CC62;&#125;.div2 &#123; width:160px;height:0;margin:0px auto; border-left:75px solid transparent; border-right:75px solid transparent; border-top:135px solid #53CC62;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web性能优化-首屏和白屏问题]]></title>
    <url>%2F2018%2F08%2F16%2Fweb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%A6%96%E5%B1%8F%E5%92%8C%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%2Fweb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%A6%96%E5%B1%8F%E5%92%8C%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。 首屏时间是指浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间。 白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素 首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成 影响白屏时间的因素：网络，服务端性能，前端页面结构设计 影响首屏时间的因素：白屏时间，资源下载执行时间 为什么打开一个H5页面会有一长段时间白屏？因为它做了很多事情，大概是： 初始化webview-&gt;请求页面-&gt;下载数据-&gt;解析HTML-&gt;请求js/css资源-&gt;dom渲染-&gt;解析JS执行-&gt;JS请求数据-&gt;解析渲染-&gt;下载渲染图片 一些简单的页面可能没有JS请求数据这一步，但大部分功能模块应该是有的，根据当前用户信息，JS向后台请求相关数据再渲染，是常规开发方式。 一般页面在dom渲染后能显示雏形，在这之前用户看到的都是白屏，等到下载渲染图片后整个页面才完整显示，首屏秒开优化就是要减少这个过程的耗时。 前端优化 上述打开一个页面的过程有很多优化点，包括前端和客户端，常见的前端和后端的性能优化在桌面时代已经有最佳实践，主要的是： 降低请求量：合并资源，减少http请求数，minify/zip压缩，懒加载，webP 加快请求速度：预解析DNS，减少域名数，并行加载，CDN分发 缓存：HTTP协议缓存请求，离线缓存manifest，离线数据缓存localStorage 渲染：JS/CSS优化，加载顺序，服务端渲染 其中对首屏启动速度影响最大的就是网络请求，所以优化的重点就是缓存，这里着重说一下前端对请求的缓存策略。这里细分一下，分成HTML的缓存，JS/CSS/image资源的缓存，以及json数据的缓存。 HTML和JS/CSS/image资源都属于静态文件，HTTP本身提供了缓存协议，浏览器实现了这些协议，可以做到静态文件的缓存，总的来说就是两种缓存： 询问是否有更新：根据if-Modified-Since/ETag等协议向后端请求询问是否有更新，没有更新返回304，浏览器使用本地缓存 直接使用本地缓存：协议里的Cache-Control/Expires字段去确定多长时间内可以不去发送请求询问更新，直接使用本地缓存 前端能做的最大限度的缓存策略是：HTML文件每次都向服务器询问是否有更新，JS/CSS/image资源文件则不请求更新，直接使用本地缓存。那JS/CSS资源文件如何更新？常见的做法是在构建页面的过程中给每个资源文件一个版本号或hash值，若资源文件有更新，版本号和hash值变化，这个资源请求的URL就变化了，同时对应的 HTML 页面更新，变成请求新的资源URL，资源也就更新了。 json 数据的缓存可以用 localStorage 缓存请求下来的数据，可以在首次显示时先用本地数据，再请求更新，这都由前端 JS 控制。 这些缓存策略可以实现 JS/CSS 等资源文件以及用户数据的缓存的全缓存，可以做到每次都直接使用本地缓存数据，不用等待网络请求。但 HTML 文件的缓存做不到，对于 HTML 文件，如果把 Expires / max-age 时间设长了，长时间只使用本地缓存，那更新就不及时，如果设短了，每次打开页面都要发网络请求询问是否有更新，再确定是否使用本地资源，一般前端在这里的策略是每次都请求，这在弱网情况下用户感受到的白屏时间仍然会很长。所以 HTML 文件的“缓存”和跟“更新”间存在矛盾。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的git命令]]></title>
    <url>%2F2018%2F08%2F15%2F%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%2F%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git四层结构 workspace工作区 stage/index暂存区 repository版本库 remote远程仓库 git文件中的四种状态 untracked未被追踪 modified表示工作区修改了某个文件但还没添加到暂存区 staged表示把工作区修改的文件添加到暂存区但还没提交到版本库 committed表示数据被安全的存储在本地库中 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置git的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圣杯布局和双飞翼布局]]></title>
    <url>%2F2018%2F08%2F15%2F%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[圣杯布局和双飞翼布局的实现，目的都是左右两栏固定宽度，中间部分自适应 圣杯布局这里实现了左(200px)右(220px)宽度固定，中间自适应，container部分高度保持一致。 说明： html代码中，middle部分首先要放在container的最前面，然后是left,right 将三者都float:left，再加上一个position:relative; middle部分width:100%;占满 此时middle占满了，所以要把left拉到最左边，使用margin-left:-100%; 此时left拉回来了，但会覆盖middle内容的左端，要把middle内容拉出来，所以要在外围container上加padding:0 220px 0 200px; middle内容拉回来了，但left也跟过来了，所以要还原，就对left使用相对定位left:-200px;同理，right也要相对定位还原right:-220px; 到这里就大致自适应好了。如果想container高度保持一致可以给left、middle、right都加上min-height:130px; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;&lt;title&gt;圣杯布局&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; *&#123;margin: 0;padding: 0;&#125; body&#123;min-width: 700px;&#125; .header, .footer&#123; border: 1px solid #333; background: #aaa; text-align: center; &#125; .left, .middle, .right&#123; position: relative; float: left; min-height: 130px; &#125; .container&#123; padding:0 220px 0 200px; overflow: hidden; &#125; .left&#123; margin-left: -100%; left: -200px; width: 200px; background: red; &#125; .right&#123; margin-left: -220px; right: -220px; width: 220px; background: green; &#125; .middle&#123; width: 100%; background: blue; word-break: break-all; &#125; .footer&#123; clear: both; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;header&quot;&gt; &lt;h4&gt;header&lt;/h4&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt; &lt;h4&gt;middle&lt;/h4&gt; &lt;p&gt;HHHHHHHHHHHHHHHHHHHHHH hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh HHHHHHHHHHHHHHHHHHHHHH hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt; &lt;h4&gt;left&lt;/h4&gt; &lt;p&gt;oooooooooooooo 00000000000000000 ooooooooooooooo ooooooooooooooo 000000000000000&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;h4&gt;right&lt;/h4&gt; &lt;p&gt;BBBBBBBBBBBBBB BBBBBBBBBBBBBBBBBB 88888888888888888888&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;h4&gt;footer&lt;/h4&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局说明： html代码中，main要放最前边，sub extra 将main sub extra 都float:left; 将main占满 width:100%; 此时main占满了，所以要把sub拉到最左边，使用margin-left:-100% ; 同理 extra使用margin-left:-220px; main内容被覆盖了吧，除了使用外围的padding，还可以考虑使用margin,给main增加一个内层div– main-inner, 然后margin:0 220px 0 200px; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;&lt;title&gt;双飞翼布局&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; *&#123;margin: 0;padding: 0;&#125; body&#123;min-width: 700px;&#125; .header, .footer&#123; border: 1px solid #333; background: #aaa; text-align: center; &#125; .sub, .main, .extra&#123; float: left; min-height: 130px; &#125; .sub&#123; margin-left: -100%; width: 200px; background: red; &#125; .extra&#123; margin-left: -220px; width: 220px; background: blue; &#125; .main&#123; width: 100%; &#125; .main-inner&#123; margin-left: 200px; margin-right: 220px; min-height: 130px; background: green; word-break: break-all; &#125; .footer&#123; clear: both; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;header&quot;&gt; &lt;h4&gt;header&lt;/h4&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;main-inner&quot;&gt; &lt;h4&gt;main&lt;/h4&gt; &lt;p&gt;HHHHHHHHHHHHHHHHHHHHHH hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh HHHHHHHHHHHHHHHHHHHHHH hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;sub&quot;&gt; &lt;h4&gt;sub&lt;/h4&gt; &lt;p&gt;oooooooooooooo 00000000000000000 ooooooooooooooo ooooooooooooooo 000000000000000&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;extra&quot;&gt; &lt;h4&gt;extra&lt;/h4&gt; &lt;p&gt;BBBBBBBBBBBBBB BBBBBBBBBBBBBBBBBB 88888888888888888888&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;h4&gt;footer&lt;/h4&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>布局</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用gulp压缩代码]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%88%A9%E7%94%A8gulp%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81%2F%E5%88%A9%E7%94%A8gulp%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[右键查看网页源代码发现有大量留白，怎么办？利用gulp压缩。 首先任意目录全局安装： npm install gulp -g 然后到站点文件夹目录： npm install gulp gulp-minify-css gulp-htmlmin gulp-htmlclean --save 接着在站点文件夹根目录新建gulpfile.js: 123456789101112131415161718192021var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;))&#125;);gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);gulp.task(&apos;default&apos;, [&apos;minify-html&apos;, &apos;minify-css&apos;]); 最后部署到Github Pages上查看效果： hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d]]></content>
      <categories>
        <category>gulp 代码压缩</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础-数组]]></title>
    <url>%2F2018%2F08%2F14%2Fjs%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84%2Fjs%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[ES5新增的5个数组迭代方法(1)every():对数组中的每一项给定函数，如果对该函数的每一项都返回true，则返回true.12345678var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var everyResult = numbers.every(function(item, index, array) &#123; return (item &gt; 2);&#125;);alert(everyResult); //false (2)some():对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。12345678var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];var someResult = numbers.some(function(item, index, array) &#123; return (item &gt; 2);&#125;);alert(someResult); //true (3)forEach():对数组中的每一项运行给定函数。这个方法没有返回值。1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;); (4)filter():对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。12345678var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3] (5)map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。12345678var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2] 数组对象和类数组对象的区别类数组对象:只包含使用从零开始，且自然递增的整数作为键名，并且定义了length表示元素个数的对象，我们就认为它是类数组对象！js中常见的类数组有arguments()对象和DOM方法的返回结果，如document.getElementsByTagName(). 123456var a = &#123;&#125;;var i = 0;while(i&lt;10)&#123; a[i] = i*i; i++;&#125; 数组对象123456var b = [];var i = 0;while(i&lt;10)&#123; b[i] = i*i; i++;&#125; 其实从源代码上面看没什么区别，但js中支持：1：类名[属性名称] = 值2：类名.属性名称 = 值要是你想在类中使用动态的属性，就必须使用第一个 看看区别：类数组对象： 1234567console.log(typeof a);//object 注意：数组也是对象哦console.log(a); // Object &#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81&#125; 很明显对象啊console.log(a.length); //undefined 区别就在这了 类数组对象没有长度的属性和数组的方法console.log(Object.prototype.toString.call(a));//[object Object] 数组对象： 1234567console.log(typeof b);//objectconsole.log(b);// [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 很明显数组啊 console.log(b.length); //8console.log(Object.prototype.toString.call(b));//[object Array] 判断一个对象是否属于类数组1234567891011function isArrayLike(o) &#123; if (o &amp;&amp; // o is not null, undefined, etc. typeof o === &apos;object&apos; &amp;&amp; // o is an object isFinite(o.length) &amp;&amp; // o.length is a finite number o.length &gt;= 0 &amp;&amp; // o.length is non-negative o.length===Math.floor(o.length) &amp;&amp; // o.length is an integer o.length &lt; 4294967296) // o.length &lt; 2^32 return true; // Then o is array-like else return false; // Otherwise it is not&#125; 由于类数组不具有数组所具有的操作数组的方法，将类数组转换为数组之后就能调用如shift,unshift,splice,slice,concat,reverse,sort等这些强大的方法。 类数组转换为数组的方法1234Array.prototype.slice.call(arrayLike)//将arguments转化为数组后，截取第一个元素之后的所有元素 var args = Array.prototype.slice.call(arguments,1); 首先Array.prototype.slice.call(arrayLike)的结果是将arrayLike对象转换成一个Array对象。所以其后面就可以直接调用数组具有的方法，例如： 1Array.prototype.slice.call(arrayLike).forEach(function(element,index)&#123; //可以随意操作每一个element了 &#125;)]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础 数组操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery(1)]]></title>
    <url>%2F2018%2F06%2F20%2FjQuery(1)%2FjQuery(1)%2F</url>
    <content type="text"><![CDATA[jQuery框架中$.ajax()的常用参数有哪些？写一个post请求并带有发送数据和返回数据的样例。 async：是否异步 url：请求地址 contentType：发送信息至服务器时内容编码类型 data：发送到服务器的数据 dataType：预期服务器返回的数据类型 type：请求类型 success：请求成功回调函数 error：请求失败回调函数 12345678910$.ajax(&#123; url:&apos;...&apos;, type:&apos;post&apos;, data:&#123; id:1 &#125;, success:function(data)&#123; alert(data); &#125;&#125;) jQuery一个对象可以同时绑定多个事件，如何实现的？多个事件同一个函数$(&#39;#div&#39;).on(&#39;click mouseover&#39;,function(){}); 多个事件不同函数12345678$(&apos;#div&apos;).on(&#123; click:function()&#123; ... &#125;, mouseover:function()&#123; ... &#125;&#125;) jQuery的slideUp动画，如果目标元素是被外部事件驱动，当鼠标快速地连续触发外部事件元素，动画会滞后的反复执行，该如何处理？jQuery.stop(); 如：$(&#39;#div&#39;).stop().animate({width:&#39;100px&#39;,100}); jQuery停止动画事件： 1234567$(&quot;#div&quot;).stop();//停止当前动画，继续下一个动画 $(&quot;#div&quot;).stop(true);//清除元素的所有动画 $(&quot;#div&quot;).stop(false, true);//让当前动画直接到达末状态 ，继续下一个动画$(&quot;#div&quot;).stop(true, true);//清除元素的所有动画，让当前动画直接到达末状态 jquery.extend与jquery.fn.extend的区别?jquery.extend为jquery类添加类方法，可以理解为静态方法 jquery.fn.extend在源码中jquery.fn==jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数 使用：jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。 jquery与jquery UI有啥区别？jquery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等。 jquery UI则是在jquery的基础上，利用jquery的扩展性，设计的插件。提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等。 jquery中如何将数组转换为json字符串，然后再转换回来？jquery中没有提供这个功能，所以你需要先编写两个jquery的扩展： 123456$.fn.stringifyArray = function(array)&#123; return JSON.stringify(array)&#125;$.fn.parseArray = function(array)&#123; return JSON.parse(array)&#125; 然后调用： $(&quot;&quot;).stringifyArray(array) 针对jquery的优化方法？ 基于class的选择器的性能相对于id选择器开销很大，因为需要遍历所有的DOM元素。优先使用ID选择器。 频繁的DOM操作，先缓存起来再操作。用jquery的链式调用更好。 如：var str = $(&quot;a&quot;).attr(&quot;href&quot;); for循环每一次都查找了数组arr的length属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑的更快。 for (var i = size, length = arr.length; i &lt; length; i++) {} jquery.fn的init方法返回的this指的是什么对象？为什么要返回this？this执行init构造函数自身，其实就是jquery实例对象，返回this是为了实现jquery的链式操作。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD、CMD、CommonJS和ES6对比]]></title>
    <url>%2F2018%2F06%2F14%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[什么是AMD、CMD、CommonJS?它们之间有什么区别？项目当中都是如何运用的？AMDAMD：异步模块定义 AMD是RequireJS在推广过程中对模块定义的规范化产出 123456789define([&apos;package/lib&apos;],function(lib)&#123; function foo()&#123; lib.log(&apos;hello world&apos;); &#125; return &#123; foo: foo &#125;; &#125;); CMDCMD:同步模块定义 CMD是SeaJS在推广过程中对模块定义的规范化产出 123456//所有的模块都通过define来定义 define(function(require,exports,module))&#123; //通过reqiure引入依赖 var $ = require(&apos;jquery&apos;); var Spinning = require(&apos;./spinning&apos;); &#125;; CommonJSCommonJS:通过module.exports来定义的 在服务端一般通过CommonJS来定义模块化开发 123456exports.area = function(r)&#123; return Math.PI * r * r; &#125;; exports.circumference = function(r)&#123; return 2 * Math.PI * r; &#125;; ES6ES6通过export/import来定义输入输出 1234567891011121314151617export default&#123; props:[&quot;num&quot;], data()&#123; return&#123; &#125; &#125;, methods:&#123; increment()&#123; this.$emit(&quot;incre&quot;); import(&apos;./../util&apos;) &#125;, decrement()&#123; this.$emit(&quot;decre&quot;); &#125; &#125; &#125;]]></content>
      <categories>
        <category>模块化开发</category>
      </categories>
      <tags>
        <tag>AMD</tag>
        <tag>CMD</tag>
        <tag>CommonJS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由基础]]></title>
    <url>%2F2018%2F06%2F13%2F%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80%2F%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[什么是前端路由？ 路由是根据不同url地址展示不同的内容或者页面 前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据url的不同返回不同的页面实现的 什么时候使用前端路由？在单页面应用，大部分页面结构不变，只改变部分内容时使用 前端路由有什么优缺点？优点 用户体验好，不需要每次都从服务器全部获取。快速展现给用户 缺点 不利于seo； 使用浏览器的前进、后退键的时候会重新发送请求，没有合理的利用缓存； 单页面无法记住之前滚动的位置，无法在前进、后退的时候记住滚动的位置。 vue-router是用来构建SPA的关键 &lt;router-link&gt;&lt;/router-link&gt;或者this.$router.push({path:&quot;}) (本质就是a标签，实现跳转) &lt;router-view&gt;&lt;/router-view&gt; (实现渲染) 什么是命名路由和命名视图？ 给路由定义不同的名字，根据名字进行匹配 给不同的router-view定义名字，通过名字进行对应组件的渲染]]></content>
      <categories>
        <category>路由</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>路由</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何把本地项目上传至github仓库]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%A6%82%E4%BD%95%E6%8A%8A%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3github%E4%BB%93%E5%BA%93%2F%E5%A6%82%E4%BD%95%E6%8A%8A%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3github%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[将本地项目上传至github仓库需要以下几个步骤： 在本地创建一个版本库（即文件夹），通过git init把它变成git仓库； 把项目复制到这个文件夹中，再通过git add .把项目添加到暂存区； 再通过git commit -m &quot;注释内容&quot;把项目提交到仓库； 新建一个远程仓库，通过git remote add origin &quot;仓库地址&quot;将本地仓库和远程仓库进行关联； 最后通过git push -u origin master(新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再次从本地仓库上传内容的时候只需要这样git push origin master即可)把本地仓库的项目推送到远程仓库（也就是github）上。 注：若新建远程仓库的时候自动创建了README文件(如果你勾选了Initialize this repository with a README创建仓库的时候会自动给你创建一个README文件)会报错failed to push some refs to https://github.com/guyibang/TEST2.git，解决方法：git pull --rebase origin master。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas入门（一）]]></title>
    <url>%2F2018%2F06%2F11%2Fcanvas%E5%85%A5%E9%97%A8%2Fcanvas%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[理解canvas元素HTML5添加的最受欢迎的元素就是canvas元素。这个元素负责在页面中设置一个区域，然后可以通过JavaScript动态的在这个区域中绘制图形。 要使用canvas元素，必须先设置其width和height属性，指定可以绘图的区域大小。与其他元素一样，canvas也能通过css为该元素添加样式，如果不添加任何样式或者不绘制任何图形在页面中是看不到该元素的。 1&lt;canvas id = &quot;drawing&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;A drawing of something.&lt;/canvas&gt; 要在这块画布上绘图，需要取得绘图上下文。而取得绘图上下文对象的引用，需要调用getcontext()方法并传入上下文的名字。 123456var drawing = document.getElementById(&quot;drawing&quot;); //确定浏览器支持&lt;canvas&gt;元素 if(drawing.getContext)&#123; var context = drawing.getContext(&quot;2d&quot;); //代码 &#125; 在使用canvas元素之前，首先要检测getcontext()方法是否存在，这一步非常重要。 2D上下文使用2D绘图上下文提供的方法，可以绘制简单的2D图形，如矩形、弧线和路径等。2D上下文的坐标开始于元素的左上角，原点坐标是(0,0)。所有坐标都基于这个原点计算，x值越大表示越靠右，y值越大表示越靠下。默认情况下，width和height表示水平和垂直方向上可用的像素数目。 填充和描边2D上下文的基本绘图操作是填充和描边。填充，就是用指定的样式（颜色、渐变和图像）填充图形；描边，就是只在图形的边缘画线。大多数2D上下文操作都会细分为填充和描边两个操作，而操作的结果取决于两个属性：fillStyle和strokeStyle。 绘制矩形矩形是唯一一种可以直接在2D上下文中绘制的形状。与矩形有关的方法包括fillRect()、strokeRect()和clearRect()。这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形的宽度和高度。这些参数的单位都是像素。 绘制路径2D上下文支持很多在画布上绘制路径的方法。通过路径可以创造出复杂的形状和线条。要绘制路径，首先必须调用beginPath()方法，表示要开始绘制新路径。然后，在调用以下方法来实际地绘制路径。 arc(x,y,radius,startAngle,endAngle,counterclockwise):以(x,y)为圆心绘制一条弧线，弧线半径为radius，起始和结束角度分别为startAngle和endAngle。最后一个参数表示是否按照逆时针方向计算，值为false表示按顺时针方向计算。 arcTo(x1,y1,x2,y2,radius):从上一点开始绘制一条弧线，到(x2,y2)为止，并且以给定的半径radius穿过(x1,y1)。 lineTo(x,y):从上一点开始绘制一条直线，到(x,y)为止。 moveTo(x,y):将绘图游标移动到(x,y)，不画线。 创建了路径之后，接下来有几种可能的选择。如果想绘制一条连接到路径起点的线条，可以调用closePath()。如果路径已经完成，你想用fillStyle填充它，可以调用fill方法。另外，还可以调用stroke()方法对路径描边，描边使用的是strokeStyle。最后还可以调用cilp()方法，这个方法可以在路径上创建一个剪切区域。 下面看一个例子，绘制一个不带数字的时钟表盘。 12345678910111213141516171819202122var drawing = document.getElementById(&quot;drawing&quot;); //确定浏览器支持&lt;canvas&gt;元素 if(drawing.getContext)&#123; var context = drawing.getContext(&quot;2d&quot;); //开始路径 context.beginPath(); //绘制外圆 context.arc(100,100,99,0,2*Math.PI,false); //绘制内圆 //在绘制内圆之前，必须把路径移动到内圆上的某一点上，以避免绘制出多余的线条 context.moveTo(194,100); context.arc(100,100,94,0,2*Math.PI,false); //绘制分针 context.moveTo(100,100); context.lineTo(100,15); //绘制时针 context.moveTo(100,100); context.lineTo(35,100); //描边路径 //调用stroke()方法，这样才能把图形绘制到画布上 context.stroke(); &#125; 绘制文本文本与图形总是如影随行。为此，2D绘图上下文也提供了绘制文本的方法。绘制文本主要有两个方法：fillText()和strokeText()。这两个方法都可以接受4个参数：要绘制的文本字符串、x坐标、y坐标和可选的最大像素宽度。而且，这两个方法都以下列3个属性为基础。 font:表示文本样式、大小及字体。 textAlign:表示文本对齐方式。 textBaseline:表示文本额基线。 变换2D绘制上下文支持各种基本的绘制变换。创建绘制上下文时，会以默认值初始化变换矩阵，在默认的变换矩阵下，所有的处理都按描述直接绘制。可通过如下方法来修改变换矩阵： rotate(angle): 围绕原点旋转图像angle角度。旋转角度，以弧度计。如需将角度转换为弧度，须使用公式degressmath.pi/180公式进行计算。例：如需旋转5度，可按如下公式进行计算：5math.pi/180 。 scale(scalex,scaley):缩放图像。 transate(x,y):将坐标原点移动到(x,y)。 transform(m1_1,m1_2,m2_1,m2_2, x,y): 直接修改变换矩阵，方式是乘以如下矩阵。 m1_1 m1_2 dx m2_1 m2_2 dy 0 0 1 setTransform(m1_1,m1_2,m2_1,m2_2,x,y): 将变换矩阵重置为默认状态，然后再调用transform()方法。 变换有可能很简单，但也可能很复杂，这都要视情况而定。 无论是刚才执行的变换，还是fillStyle、strokeStyle等属性，都会在当前上下文中一直有效，除非再对上下文进行什么修改。虽然没有什么办法把上下文中的一切都重置为默认值，但有两个方法可以跟踪上下文的状态变化。如果你知道将来还要返回某组属性与变换的组合，可以调用save()方法。调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保存。然后可以对上下文进行其他修改。等想要回到之前保存的设置时，可以调用restore()方法，在保存设置的栈结构中向前返回一级，恢复之前的状态。连续调用save()可以把更多的设置保存到栈结构中，之后再连续调用restore()则得以一级一级返回。需要注意的是，save()方法保存的只是对绘图上下文的设置和变换，不会保存绘图上下文的内容。 绘制图像2d绘制上下文内置了对图像的支持。如果你先想把一幅图像绘制到画布上，可以使用drawimage()方法。最简单的调用方式是传入一个html&lt;img&gt;元素，以及绘制该图像的起点的x和y坐标。例如： 12var image = document.images[0];context.drawImage(img,10,10); 这两行代码取得了文档中的第一幅图像，然后将它绘制到上下文中，起点为(10,10)。 还可以选择把图像中的某个区域绘制到上下文中。drawimage()方法的这种调用总共需要传入9个参数：要绘制的图像，源图像的x坐标，源图像的y坐标，源图像的宽度，源图像的高度，目标图像的x坐标，目标图像的y坐标，目标图像的宽度，目标图像的高度。这样调用drawimage()方法可以获得最多的控制。例如： 1context.drawImage(img,0,10,50,50,0,100,40,60); 这行代码只会把原始图像的一部分绘制到画布上。原始图像的这一部分的起点为(0,10)，宽和高都是50像素。最终绘制到上下文中的图像的起点是(0,100)，而大小变成了40×60像素。 阴影2D上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影。 shadowColor:用CSS颜色格式表示的阴影颜色，默认为黑色。 shadowOffsetX:形状或路径x轴方向的阴影偏移量，默认为0。 shadowOffsetY:形状或路径y轴方向的阴影偏移量，默认为0。 shadowBlur:模糊的像素数，默认0，即不模糊。 渐变渐变由CanvasGradient实例表示，很容易通过2D上下文来创建和修改。要创建一个新的线性渐变，可以调用createGradient()方法。这个方法接受4个参数：起点的x坐标、起点的y坐标、终点的x坐标、终点的y坐标。调用这个方法后，它会创建一个指定大小的渐变，并返回CanvasGradient对象的实例。 创建了渐变对象之后，下一步就是使用addColorStop()方法来指定色标。这个方法接收两个参数：色标位置和CSS颜色值。色标位置是一个0(开始的颜色)到1(结束的颜色)之间的数字。例如： 123var gradient = context.createLinearGradient(30,30,70,70);gradient.addColor(0,&quot;white&quot;);gradient.addColor(1,&quot;black&quot;);]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 添加点击爱心效果]]></title>
    <url>%2F2018%2F06%2F07%2FHexo-Next-%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E7%88%B1%E5%BF%83%E6%95%88%E6%9E%9C%2Findex%2Findex%2F</url>
    <content type="text"><![CDATA[给NexT主题内添加页面点击出现爱心的效果 创建js文件在/themes/next/source/js/src下新建文件clicklove.js，接着把该链接下的代码拷贝粘贴到clicklove.js文件中。 代码如下： 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 修改_layout.swig在\themes\next\layout\_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; 刷新页面，即可实现点击出现爱心效果。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题下添加相册模块]]></title>
    <url>%2F2018%2F06%2F07%2FHexo-NexT%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C%E6%A8%A1%E5%9D%97%2FHexo-NexT%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[新建相册页面首先新建相册页面hexo new page photos,将会在source/下创建photos/index.md，在其中添加type: photos。 _config.yml在主题_config.yml文件中对应位置menu里添加Photos: /photos/，这样生成后就能在页面的菜单栏中出现相册选项。 json在博客根目录下新建uploadPhotos文件夹，里面将会存放照片以及相关js文件。新建uploadPhotos/Images/文件夹，然后在其中存放需要在页面中展示的照片集（在GitHub中新建相册库，并上传图片）。新建uploadPhotos/tool.js文件，里面内容如下，主要功能是访问照片文件夹，获取每张照片的size和name，并生成对应的json文件：命令：Git Bash中键入 node tool.js生成json。注：若出现Error: Cannot find module &#39;image-size&#39;问题，请在Git Bash中键入对应命令npm install image-size进行安装。1234567891011121314151617181920212223242526272829&quot;use strict&quot;; const fs = require(&quot;fs&quot;); const sizeOf = require(&apos;image-size&apos;); const path = &quot;Images&quot;; const output = &quot;../themes/next/source/photos/photoslist.json&quot;; var dimensions; fs.readdir(path, function (err, files) &#123; if (err) &#123; return; &#125; let arr = []; (function iterator(index) &#123; if (index == files.length) &#123; fs.writeFile(output, JSON.stringify(arr, null, &quot;\t&quot;)); return; &#125; fs.stat(path + &quot;/&quot; + files[index], function (err, stats) &#123; if (err) &#123; return; &#125; if (stats.isFile()) &#123; dimensions = sizeOf(path + &quot;/&quot; + files[index]); console.log(dimensions.width, dimensions.height); arr.push(dimensions.width + &apos;.&apos; + dimensions.height + &apos; &apos; + files[index]); &#125; iterator(index + 1); &#125;) &#125;(0)); &#125;); json文件样例如下(图片宽度.图片高度+空格+图片名.图片格式):12345678[ &quot;440.556 IMG_0101.jpg&quot;, &quot;440.613 IMG_0102.jpg&quot;, &quot;440.612 IMG_0103.jpg&quot;, &quot;440.612 IMG_0104.jpg&quot;, &quot;200.245 IMG_0105.jpg&quot;, &quot;440.610 IMG_0106.jpg&quot;,] photo.js新建themes/next/source/photos/photo.js文件，其中photos文件夹是自己创建的.photos.js内容如下，主要功能是访问json文件内容，遍历每行数据，并在页面对应位置上放置代码，展示图片（其中图片链接为自个GitHub相册库中图片的链接）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647photo =&#123; page: 1, offset: 20, init: function () &#123; var that = this; $.getJSON(&quot;/photos/photoslist.json&quot;, function (data) &#123; that.render(that.page, data); //that.scroll(data); &#125;); &#125;, render: function (page, data) &#123; var begin = (page - 1) * this.offset; var end = page * this.offset; if (begin &gt;= data.length) return; var html, imgNameWithPattern, imgName, imageSize, imageX, imageY, li = &quot;&quot;; for (var i = begin; i &lt; end &amp;&amp; i &lt; data.length; i++) &#123; imgNameWithPattern = data[i].split(&apos; &apos;)[1]; imgName = imgNameWithPattern.split(&apos;.&apos;)[0] imageSize = data[i].split(&apos; &apos;)[0]; imageX = imageSize.split(&apos;.&apos;)[0]; imageY = imageSize.split(&apos;.&apos;)[1]; li += &apos;&lt;div class=&quot;card&quot; style=&quot;width:330px&quot;&gt;&apos; + &apos;&lt;div class=&quot;ImageInCard&quot; style=&quot;height:&apos;+ 330 * imageY / imageX + &apos;px&quot;&gt;&apos; + &apos;&lt;a data-fancybox=&quot;gallery&quot; href=&quot;https://github.com/asdfv1929/BlogPhotos/blob/master/Images/&apos; + imgNameWithPattern + &apos;?raw=true&quot; data-caption=&quot;&apos; + imgName + &apos;&quot;&gt;&apos; + &apos;&lt;img src=&quot;https://github.com/asdfv1929/BlogPhotos/blob/master/Images/&apos; + imgNameWithPattern + &apos;?raw=true&quot;/&gt;&apos; + &apos;&lt;/a&gt;&apos; + &apos;&lt;/div&gt;&apos; + // &apos;&lt;div class=&quot;TextInCard&quot;&gt;&apos; + imgName + &apos;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos; &#125; $(&quot;.ImageGrid&quot;).append(li); $(&quot;.ImageGrid&quot;).lazyload(); this.minigrid(); &#125;, minigrid: function() &#123; var grid = new Minigrid(&#123; container: &apos;.ImageGrid&apos;, item: &apos;.card&apos;, gutter: 12 &#125;); grid.mount(); $(window).resize(function() &#123; grid.mount(); &#125;); &#125;&#125;photo.init(); photos.swig新建themes/next/layout/photos.swig文件，其内容模仿tag.swig中内容（直接复制粘贴），然后将其中的tag全部替换为photos。 photos.css新建themes/next/source/photos/photos.css样式文件，内容如下：12345.ImageGrid &#123;width: 100%;max-width: 1040px;margin: 0 auto; text-align: center;&#125;.card &#123;overflow: hidden;transition: .3s ease-in-out; border-radius: 8px; background-color: #ddd;&#125;.ImageInCard &#123;&#125;.ImageInCard img &#123;padding: 0 0 0 0;&#125;.TextInCard &#123;line-height: 54px; background-color: #ffffff; font-size: 24px;&#125; page.swig修改themes/next/layout/page.swig文件，添加下面代码中中间page.type === “photos”那两行。123456789101112&#123;% block title %&#125;&#123;##&#125;&#123;% set page_title_suffix = &apos; | &apos; + config.title %&#125;&#123;##&#125;&#123;% if page.type === &quot;categories&quot; and not page.title %&#125;&#123;# #&#125;&#123;&#123; __(&apos;title.category&apos;) + page_title_suffix &#125;&#125;&#123;##&#125;&#123;% elif page.type === &quot;tags&quot; and not page.title %&#125;&#123;# #&#125;&#123;&#123; __(&apos;title.tag&apos;) + page_title_suffix &#125;&#125;&#123;##&#125;&#123;% elif page.type === &quot;photos&quot; and not page.title %&#125;&#123;# #&#125;&#123;&#123; __(&apos;title.photos&apos;) + page_title_suffix &#125;&#125;&#123;##&#125;&#123;% else %&#125;&#123;# #&#125;&#123;&#123; page.title + page_title_suffix &#125;&#125;&#123;##&#125;&#123;% endif %&#125;&#123;##&#125;&#123;% endblock %&#125; _layout.swig在主题_layout.swig文件末尾，添加内容：123456&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/npm/lazyload@2.0.0-beta.2/lazyload.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/photos/photos.css&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/photos/photo.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js&quot;&gt;&lt;/script&gt; 整个过程结束，查看图片是否以瀑布流的方式呈现。 总结 在花了两天的时间来实现相册模块，网上查阅了很多博文，期间碰到很多问题都一一解决了。期间花费时间最长的一个问题是图片无法加载，后来发现是图片链接地址写错，真的是坑。将照片存放在一个新的github仓库中，单个照片的链接居然跟外层的链接不一样。我还以为是其他地方出了问题，一直在改其他地方。 参考链接博主给了我很大帮助，在此表示感谢。 参考链接Hexo NexT主题内添加相册功能]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海康前端开发实习面经]]></title>
    <url>%2F2018%2F06%2F05%2F%E6%B5%B7%E5%BA%B7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%2F%E6%B5%B7%E5%BA%B7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[自我介绍 Ajax相关知识 数据库增删改查 如何获取元素（DOM操作） 盒模型 存储cookie、sessionStorage、localStorage 常用的http状态码 常用的http请求方式 GET和POST区别 闭包、作用域 事件冒泡、事件捕获 布局，div+css 框架vue组件相互通信、jquery、bootStrap 对后端有了解么]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里前端开发实习生面经]]></title>
    <url>%2F2018%2F06%2F04%2F%E9%98%BF%E9%87%8C%E9%9D%A2%E7%BB%8F%2F%E9%98%BF%E9%87%8C%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[阿里一面 自我介绍一下 DOCTYPE是什么，有几种模式，分别阐述一下 CSS盒模型在W3C下和IE下有什么不同 有一堆2分、3分、5分的硬币，要凑成一块钱，有几种组合，用代码实现一下 一个ul下面有很多li，把这些li倒过来放置（包括里面的内容），用DOM操作实现一下 一个li绑定了一个事件，然后把这个li删除了，问这个事件还存在么，为什么 为什么想从事前端开发 阿里二面 自我介绍，说了有发明专利公开，先讲一下发明专利的东西 箭头函数(作用域) 数组常用的API 事件传播过程（事件冒泡和事件捕获） addEventListener有几个参数，第三个参数什么意思 setTimeout有几个参数，如果第二个参数设置为0，会立即执行么（单线程） 前序遍历不用递归写，先用栈写，再用队列写 看了哪些前端开方方面的书 最快的排序是哪种，快排的实现原理，罗列出所有时间复杂度nlogn的排序算法 在搭建个人博客中遇到的问题 阿里三面 用三句简短的话介绍下自己 阐述一下专利的内容以及应用场景 为什么想从事前端开发 最近在干什么（搭博客） 有没有自己的代码沉淀？？？？ 项目中遇到哪些问题怎么解决的 Github中有没有可以展示的作品 讲一下最近一篇博客写了什么 笔试中一道编程题实现一下（CSS选择器）]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用HEXO+github搭建个人博客]]></title>
    <url>%2F2017%2F11%2F02%2Fhello%2Fhello%2F</url>
    <content type="text"><![CDATA[如何用HEXO+github搭建个人博客HEXO是一个简单的、轻量的、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github上。原理：github存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的内容就是讲这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。系统环境配置：要使用Hexo，需要在你的系统中支持Node.js以及Git。安装Node（必须），作用：用来生成静态页面，到Node.js官网下载和自己电脑相匹配的版本，除了指定安装路径，一路安装即可。安装Git（必须），作用：把本地的hexo内容提交到github上去，申请github账号，作用：是用来做博客的远成仓库、域名、服务器之类的。验证软件是否安装正确：同时按下win键或R键（或点击“开始菜单”&gt;点击“运行”），打开运行窗口，输入“cmd”，然后输入以下命令：显示版本信息，说明安装成功。申请gitub账号：注册完成后，点击“New repository”，新建一个版本库。输入repository name:yourname.github.io(yourname与你的注册用户名一致，这就是你博客的域名了)。到此，github账号申请完成。安装hexo：在自己认为合适的地方创建一个文件夹，这里以E：/hexo为例，首先在E盘目录下创建HEXO文件夹，并在命令行的窗口进入到该目录下在命令行中输入：可能会看到一个WARN，但是不用担心，不会影响正常使用，然后输入：等待进度条安装到100，然后测试hexo是否安装完成，输入：安装完成。HEXO的相关配置：1.初始化HEXO，接着上面的操作，输入：再输入：之后npm将会自动安装你需要的组件，只需等待npm操作即可。2.首次体验HEXO继续操作，同样在命令行输入：然后输入：提示：在浏览器中打开http://localhost:4000/，你将会看到：HEXO常用的几个命令：（1） hexo generate (hexo g)生成静态文件，会在当前目录下生成一个新的叫做public的文件夹（2） hexo server(hexo s)启动本地web服务，用于博客的预览（3） hexo deploy(hexo d)部署博客到远端（GitHub平台）将HEXO与github联系起来：大致分为两步：（1）配置git个人信息；（2）配置Deployment Hexo不是处理命令时：$ npm install hexo -g]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP报文格式解析]]></title>
    <url>%2F2017%2F11%2F02%2FHTTP%2FHTTP%2F</url>
    <content type="text"><![CDATA[HTTP报文格式解析一．概述HTTP报文是面向文本的，报文中的每一个字段都是ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie、sessionStorage区别]]></title>
    <url>%2F2017%2F09%2F29%2Fcookie%E3%80%81sessionStorage%E5%8C%BA%E5%88%AB%2Fcookie%E3%80%81sessionStorage%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[cookie 和session 的区别详解:1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer(3)]]></title>
    <url>%2F2017%2F09%2F15%2Foffer%2Foffer%2F</url>
    <content type="text"><![CDATA[题目：输入一个链表，从尾到头打印链表每个节点的值。function printListFromTailToHead(head){ var arr = []; while(head!=null){ arr.push(head.val); head = head.next; } return arr.reverse();}思路：先将链表每个结点的值存入数组中，然后通过数组的reverse()方法，即可从尾到头打印。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo生成博文插入图片]]></title>
    <url>%2F2017%2F09%2F11%2Fhexo%E5%8D%9A%E6%96%87%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2Fhexo%E5%8D%9A%E6%96%87%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[1.把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true。2.在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git。3.等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹。4.最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：。注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。5.最后检查一下，hexo g生成页面后，进入public\2017\02\26\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&quot;&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer(2):替换空格]]></title>
    <url>%2F2017%2F09%2F10%2Foffer%2F%E5%89%91%E6%8C%87offer(2)%2F</url>
    <content type="text"><![CDATA[题目：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。function replaceSpace(str){ return str.replace(/\s/g,’%20’);}思路：用正则表达式查找数字组中的所有空格，然后用str.replace替换。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer(1):二维数组中的查找]]></title>
    <url>%2F2017%2F09%2F10%2Foffer%2F%E5%89%91%E6%8C%87offer(1)%2F</url>
    <content type="text"><![CDATA[题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。function Find(target, array){ var row = array.length; //行数 var col = array[0].length; //列数 var r = row-1; //从左下角开始比较 var c = 0; while( r &gt;= 0 &amp;&amp; c &lt;= col-1){ if(target &gt; array[r][c]){ c++; }else if(target &lt; array[r][c]){ r–; }else{ return true; } } return false;}思路：因为矩阵的特殊性，所以先从最后一行第一列开始比较，小于则向上查找，大于则向后查找。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
